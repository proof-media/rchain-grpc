import functools
import json
from contextlib import AbstractContextManager
from typing import Any, Callable, Generic, Type, TypeVar

from grpc import Channel, insecure_channel

from .exceptions import ConnectionClosedException

gRPCStub = TypeVar('gRPCStub')


class Connection(AbstractContextManager, Generic[gRPCStub]):
    """proxy class from stub from grpc. Support `close` method
    and can be usee as context manager"""

    def __init__(self, channel: Channel, stub: gRPCStub) -> None:
        # NOTE: using super to avoid recursion
        super().__setattr__('connected', True)
        super().__setattr__('_channel', channel)
        super().__setattr__('_stub', stub)

    def close(self) -> None:
        self._channel.close()
        del self._channel
        del self._stub
        # NOTE: using super to avoid recursion
        super().__setattr__('connected', False)

    def __getattr__(self, key: str) -> Any:
        if not object.__getattribute__(self, 'connected'):
            raise ConnectionClosedException()
        return getattr(self._stub, key)

    def __setattr__(self, key: str, val: Any) -> None:
        if not object.__getattribute__(self, 'connected'):
            raise ConnectionClosedException()
        setattr(self._stub, key, val)

    def __exit__(self, *args, **kwargs) -> None:
        self.close()
        return super().__exit__(*args, **kwargs)


def create_connection(
    stub: Type[gRPCStub],
    channel_fn: Callable[[str], Channel] = insecure_channel,
    host: str = '127.0.0.1',
    port: int = 40401,
) -> Connection[gRPCStub]:
    """create new connection from `stub` generated by grpcio.
    Connection can be used as context manager"""

    channel = channel_fn(f'{host}:{port}')
    return Connection[stub](channel, stub(channel))


def create_connection_builder(stub: Type[Connection]) -> Callable[..., Connection]:
    """factory for cinnection functions created from `stub` generated by grpcio"""

    return functools.partial(create_connection, stub=stub)


def is_equal(d1: dict, d2: dict) -> bool:
    kwargs = {'sort_keys': True, 'indent': 0}
    return json.dumps(d1, **kwargs) == json.dumps(d2, **kwargs)


def parse_expr_type(expr):
    gtype, gvalue = list(expr.items()).pop()
    if gtype == 'gString':
        assert isinstance(gvalue, str)
    elif gtype == 'gBool':
        assert isinstance(gvalue, bool)
    elif gtype == 'gInt':
        gvalue = int(gvalue)
    else:
        raise ValueError(f"Unknown type: {gtype}")
    return gvalue


def parse_expr_single_mapping(expr, key):
    return expr.get(key, {}).get('exprs', []).pop()


def parse_expr_mapping(expr, map_key):
    myDict = {}
    for row in expr.get(map_key, {}).get('kvs'):
        myDict[parse_expr(parse_expr_single_mapping(row, 'key'))] = \
            parse_expr(parse_expr_single_mapping(row, 'value'))
    return myDict


def parse_expr(expr, map_key='eMapBody'):
    if map_key in expr:
        return parse_expr_mapping(expr, map_key)
    else:
        return parse_expr_type(expr)


def parse_output(ret):
    block = ret.get('blockResults').pop()
    data = []
    for par in block.get('postBlockData'):
        for expr in par.get('exprs', []):
            data.append(parse_expr(expr))
    return data
